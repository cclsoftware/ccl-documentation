

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; CCL Cross-platform Framework Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../_static/cmakerole-sphinx_rtd_theme.css?v=982d3367" />
      <link rel="stylesheet" type="text/css" href="../_static/doxyrest-pygments.css?v=ff3f4257" />
      <link rel="stylesheet" type="text/css" href="../_static/doxyrest-sphinx_rtd_theme.css?v=b6ca47bd" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script src="../_static/target-highlight.js?v=df7d332b"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Building CCL" href="building.html" />
    <link rel="prev" title="CCL Cross-platform Framework" href="index.html" />
    <link href="../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #293F50" >

          
          
          <a href="../index.html">
            
              <img src="../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../cclstartguide/index.html">Getting Started with CCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cmakeguide/index.html">CMake Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">CCL Cross-platform Framework</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-short-history-lesson">A short history lesson</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basic-structure">Basic structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-libraries">Dynamic libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="#static-libraries">Static libraries</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interface-concept">Interface concept</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocating-objects">Allocating objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scripting">Scripting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-information">Type information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-allocations">Memory allocations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#strings">Strings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#file-system-and-urls">File system and URLs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#threads">Threads</a></li>
<li class="toctree-l3"><a class="reference internal" href="#signals">Signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plug-ins-and-services">Plug-ins and services</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="building.html">Building CCL</a></li>
<li class="toctree-l2"><a class="reference internal" href="howtos.html">CCL How-tos</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/index.html">Tutorials</a></li>
<li class="toctree-l2"><a class="reference internal" href="details/index.html">CCL in Detail</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">CCL Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="cmdtools/index.html">CCL Command-line Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference/index.html">API Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../skinlanguage/index.html">CCL Skin Definition Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../corelibrary/index.html">Core Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coreskin/reference/core-skin-elements-classmodel.html">Core Skin Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extension/index.html">Extension Developer Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #293F50" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CCL Cross-platform Framework Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">CCL Cross-platform Framework</a></li>
      <li class="breadcrumb-item active">Introduction</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h1>
<p id="ccl-introduction">Welcome to Crystal Class Library® (CCL), a cross-platform framework for desktop, mobile, and embedded application development in C++. As of 2026, the following target platforms are supported:</p>
<ul class="simple">
<li><p>Windows (based on Win32)</p></li>
<li><p>macOS and iOS/iPadOS (based on Cocoa)</p></li>
<li><p>Linux (with support for Gnome and KDE)</p></li>
<li><p>Android</p></li>
</ul>
<p>You can think of CCL as a unified virtual operating system. Instead of using platform-specific APIs and UI elements, applications are based on an additional abstract layer to make them portable between OS platforms. For example, you can develop and debug most of a mobile app for iOS/iPadOS on a PC using Visual Studio or VS Code, or release an application for all supported platforms simultaneously with little overhead.</p>
<p>The code esthetics of CCL is inspired by Java. It is using camel case instead of snake case like some popular C++ libraries. Code and documentation are written in American English. Many concepts used in CCL will be familiar if you have worked with other application frameworks like .NET, MFC, Qt, etc. before. However, there are some differences you need to learn and be aware of.</p>
<section id="a-short-history-lesson">
<h2>A short history lesson<a class="headerlink" href="#a-short-history-lesson" title="Link to this heading"></a></h2>
<p>The first version of CCL was created by Matthias Juwan in 1999. The framework is distributed and maintained by CCL Software Licensing GmbH. PreSonus is a contributor since 2009.</p>
<p>The code is evolving continuously to adapt to new requirements. In 2012, parts of the framework were moved into the Core Library to allow reuse and sharing of code with RTOS-based platforms. By adding iOS as first mobile platform the same year, the framework was extended with features like multi-touch input and hardware-accelerated graphical animations.</p>
<p>For more information and licensing terms and conditions, please visit <a class="reference external" href="https://ccl.dev">ccl.dev</a>.</p>
</section>
<section id="basic-structure">
<h2>Basic structure<a class="headerlink" href="#basic-structure" title="Link to this heading"></a></h2>
<p>The framework is divided into several libraries, some are linked statically to the application and some dynamically.</p>
<section id="dynamic-libraries">
<h3>Dynamic libraries<a class="headerlink" href="#dynamic-libraries" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>ccltext</strong>: everything related to Unicode strings, XML, localization support, etc.</p></li>
<li><p><strong>cclsystem</strong>: basics like file system access, multithreading and synchronization, IPC, plug-in loading, etc.</p></li>
<li><p><strong>cclgui</strong>: everything needed for a graphical user interface, XML-based skins, etc.</p></li>
<li><p><strong>cclnet</strong>: support for sockets, TCP, UDP, HTTP, etc.</p></li>
<li><p><strong>cclsecurity</strong>: crypthographic cipher algorithms, etc.</p></li>
</ul>
</section>
<section id="static-libraries">
<h3>Static libraries<a class="headerlink" href="#static-libraries" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>cclbase</strong>: provides RTTI, collections, persistence, etc. (linked into all other libs, except <strong>ccltext</strong>)</p></li>
<li><p><strong>cclapp</strong>: application component classes and parameters, etc.</p></li>
</ul>
<p>The reason for this separation is simple. A large-scale desktop or mobile application needs a certain level of modularity to stay maintainable for a longer period of time and certain features are split into plug-ins. The plug-ins also want to make use of the framework and instead of compiling the same code into all binaries multiple times, the majority of the framework itself is linked and loaded dynamically.</p>
<p>Another architectural reason is that in a large code base you don’t want everyone in the team to mess with the fundamentals shared by all applications and e.g. create several versions of a class which might easily fit into a single, unified multi-purpose class. Dynamic linking sets a hard limit between the foundation and the application code.</p>
<p>That said, you’ll notice that you sometimes cannot derive your own classes directly from framework classes via C++ inheritance. The good thing is, in general you don’t have to and CCL provides alternative concepts which often result in better structured code. We’ll follow up on that below.</p>
</section>
</section>
<section id="interface-concept">
<h2>Interface concept<a class="headerlink" href="#interface-concept" title="Link to this heading"></a></h2>
<p>CCL heavily uses the interface concept as found in <a class="reference external" href="https://en.wikipedia.org/wiki/Component_Object_Model">COM</a>, <a class="reference external" href="https://en.wikipedia.org/wiki/XPCOM">XPCOM</a>, <a class="reference external" href="https://www.openoffice.org/udk/">UNO</a>, etc. At the C++ language level, interfaces are abstract classes with pure virtual methods only without any data members. The basic interface <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/struct_CCL_IUnknown.html#doxid-struct-c-c-l-1-1-i-unknown"><span class="std std-ref"><span class="pre">CCL::IUnknown</span></span></a></code> provides methods for reference counting (retain/release) and a query mechanism to obtain additional purpose-specific interfaces of an object (queryInterface). On the semantic level, an interface can be seen like a contract that is obligatory to all classes implementing it. The implementation details of a class are hidden and they don’t matter to the caller who can see the interface only - the caller can simply rely on the contract.</p>
<p>Interfaces also help with ABI-compatibility between multiple dynamically linked binaries. The ABI (Application Binary Interface) is the memory layout of your class at runtime. An application would simply crash if calls between modules aren’t compatible on this lower level if e.g. members of a class are added or removed. Interfaces provide the required stability. They remain stable between framework releases, some of them are even marked frozen for eternity. Like with any other rule, there are exceptions here as well. If binary compatibility is lost, the framework revision is incremented and all related binaries have to be recompiled. This doesn’t happen very often, though.</p>
<p>Interface names are prefixed with ‘I’ like ‘IUnknown’. They are identified with 16 byte globally unique identifiers
(<a class="reference external" href="http://en.wikipedia.org/wiki/Globally_unique_identifier">GUID</a>).</p>
</section>
<section id="allocating-objects">
<h2>Allocating objects<a class="headerlink" href="#allocating-objects" title="Link to this heading"></a></h2>
<p>Framework classes that you can’t access directly are either created with special functions in the <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/namespace_CCL_System.html#doxid-namespace-c-c-l-1-1-system"><span class="std std-ref"><span class="pre">CCL::System</span></span></a></code> namespace exported by the framework DLLs, or by using the <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/namespace_CCL.html#doxid-namespace-c-c-l-1aca367eab4c59a96a662ae321f84739be"><span class="std std-ref"><span class="pre">CCL::ccl_new</span></span></a></code> template function.</p>
<p>In regular C++ you would create and release object like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Object</span><span class="o">*</span> <span class="n">object</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">;</span>
<span class="k">delete</span> <span class="n">object</span><span class="p">;</span>
</pre></div>
</div>
<p>In CCL, you’ll often notice calls like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">IObject</span><span class="o">*</span> <span class="n">object</span> <span class="o">=</span> <span class="n">ccl_new</span><span class="o">&lt;</span><span class="n">IObject</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">ClassID</span><span class="o">::</span><span class="n">Object</span><span class="p">);</span>
<span class="n">object</span><span class="o">-&gt;</span><span class="n">release</span> <span class="p">();</span>
</pre></div>
</div>
<p>In the second code snippet, the class is identified by a <a class="reference external" href="http://en.wikipedia.org/wiki/Globally_unique_identifier">GUID</a> and the requested interface is passed as template argument.</p>
<p>To deal with reference counting, we use smart pointer classes like <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/class_CCL_AutoPtr.html#doxid-class-c-c-l-1-1-auto-ptr"><span class="std std-ref"><span class="pre">CCL::AutoPtr</span></span></a></code> and <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/class_CCL_SharedPtr.html#doxid-class-c-c-l-1-1-shared-ptr"><span class="std std-ref"><span class="pre">CCL::SharedPtr</span></span></a></code>.</p>
</section>
<section id="scripting">
<h2>Scripting<a class="headerlink" href="#scripting" title="Link to this heading"></a></h2>
<p>CCL::IUnknown is a fundamental piece when writing native C++ code with CCL. However, to support dynamically typed scripting languages, the <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/struct_CCL_IObject.html#doxid-struct-c-c-l-1-1-i-object"><span class="std std-ref"><span class="pre">CCL::IObject</span></span></a></code> interface comes into play. It exposes type information which can be used by a scripting engine to bridge calls between the native and the scripting world at runtime. CCL includes the <a class="reference external" href="https://spidermonkey.dev/">Mozilla SpiderMonkey JavaScript engine</a> as a service for applications.</p>
</section>
<section id="type-information">
<h2>Type information<a class="headerlink" href="#type-information" title="Link to this heading"></a></h2>
<p>All classes derived from <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/class_CCL_Object.html#doxid-class-c-c-l-1-1-object"><span class="std std-ref"><span class="pre">CCL::Object</span></span></a></code> provide runtime type information (RTTI) via <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/class_CCL_MetaClass.html#doxid-class-c-c-l-1-1-meta-class"><span class="std std-ref"><span class="pre">CCL::MetaClass</span></span></a></code> and thus dynamic type casting. Instead of the language feature dynamic_cast&lt;&gt;, we use our own <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/namespace_CCL.html#doxid-namespace-c-c-l-1acd705038499fe2347d5e8f757ffc999c"><span class="std std-ref"><span class="pre">CCL::ccl_cast</span></span></a></code> and <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/namespace_CCL.html#doxid-namespace-c-c-l-1a57e2f1397008d938560e5ff33919cebd"><span class="std std-ref"><span class="pre">CCL::unknown_cast</span></span></a></code> templates. Why? Because we have to deal with interfaces and we need our own meta classes anyway for object serialization and scripting support.</p>
<p><code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/namespace_CCL.html#doxid-namespace-c-c-l-1acd705038499fe2347d5e8f757ffc999c"><span class="std std-ref"><span class="pre">CCL::ccl_cast</span></span></a></code> can be used when you already have pointer to a class derived from <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/class_CCL_Object.html#doxid-class-c-c-l-1-1-object"><span class="std std-ref"><span class="pre">CCL::Object</span></span></a></code>. To cast from an interface pointer (e.g. <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/struct_CCL_IUnknown.html#doxid-struct-c-c-l-1-1-i-unknown"><span class="std std-ref"><span class="pre">CCL::IUnknown</span></span></a></code>), <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/namespace_CCL.html#doxid-namespace-c-c-l-1a57e2f1397008d938560e5ff33919cebd"><span class="std std-ref"><span class="pre">CCL::unknown_cast</span></span></a></code> has to be used. In both cases, the class you are casting to has to implemented in the same module as the calling code, otherwise the cast fails.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// casting from an Object pointer to a more concrete class</span>
<span class="n">Container</span><span class="o">*</span> <span class="n">container</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span><span class="o">*</span> <span class="n">array1</span> <span class="o">=</span> <span class="n">ccl_cast</span><span class="o">&lt;</span><span class="n">ObjectArray</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">container</span><span class="p">);</span>

<span class="c1">// casting from an interface pointer to a concrete class</span>
<span class="n">IUnknown</span><span class="o">*</span> <span class="n">unknown</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span><span class="o">*</span> <span class="n">array2</span> <span class="o">=</span> <span class="n">unknown_cast</span><span class="o">&lt;</span><span class="n">ObjectArray</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">unknown</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="memory-allocations">
<h2>Memory allocations<a class="headerlink" href="#memory-allocations" title="Link to this heading"></a></h2>
<p>All memory allocations made by CCL are redirected to our own memory management functions (<code class="docutils literal notranslate"><span class="pre">Core::core_malloc</span></code>, <code class="docutils literal notranslate"><span class="pre">Core::core_free</span></code>, etc) and end up in the <strong>ccltext</strong> library. This way we can override the default memory allocator of the C runtime library with more efficient implementations and also add heap debugging features.</p>
<p>We use our own uppercase <code class="docutils literal notranslate"><span class="pre">NEW</span></code> macro instead of the lowercase <code class="docutils literal notranslate"><span class="pre">new</span></code> language operator to be able to trace back memory leaks to the source file and line number of allocation in debug builds. This is of course stripped from release builds.</p>
</section>
<section id="strings">
<h2>Strings<a class="headerlink" href="#strings" title="Link to this heading"></a></h2>
<p>Like other application frameworks, CCL also provides string classes. We differentiate between Unicode strings for user data and simple ASCII strings used as internal identifiers, represented by the two classes <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/class_CCL_String.html#doxid-class-c-c-l-1-1-string"><span class="std std-ref"><span class="pre">CCL::String</span></span></a></code> and <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/class_CCL_MutableCString.html#doxid-class-c-c-l-1-1-mutable-c-string"><span class="std std-ref"><span class="pre">CCL::MutableCString</span></span></a></code>. Both support copy-on-write semantics and both can be passed safely between ABI boundaries as the memory is managed by the <strong>ccltext</strong> dynamic library.</p>
<p>See also <a class="reference internal" href="details/strings.html#using-strings"><span class="std std-ref">Using strings</span></a> for details about using the string classes.</p>
</section>
<section id="file-system-and-urls">
<h2>File system and URLs<a class="headerlink" href="#file-system-and-urls" title="Link to this heading"></a></h2>
<p>Files on disk, in a network or from other sources are addressed using the <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/class_CCL_Url.html#doxid-class-c-c-l-1-1-url"><span class="std std-ref"><span class="pre">CCL::Url</span></span></a></code> class with interface <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/struct_CCL_IUrl.html#doxid-struct-c-c-l-1-1-i-url"><span class="std std-ref"><span class="pre">CCL::IUrl</span></span></a></code> (see also <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/namespace_CCL.html#doxid-namespace-c-c-l-1aa15c234174ac53794430248181764561"><span class="std std-ref"><span class="pre">CCL::UrlRef</span></span></a></code>).
An URL consists of a protocol, hostname, path and optional parameters.</p>
<p>On Windows, a file system location like <code class="docutils literal notranslate"><span class="pre">C:\Users\Me\Documents</span></code> is represented as <code class="docutils literal notranslate"><span class="pre">file:///C:/Users/Me/Documents</span></code>. You can access the file system singleton via</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">CCL</span><span class="o">::</span><span class="n">System</span><span class="o">::</span><span class="n">GetFileSystem</span> <span class="p">(</span><span class="n">see</span> <span class="n">CCL</span><span class="o">::</span><span class="n">INativeFileSystem</span><span class="p">).</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="details/filesystem_urls.html#file-system-urls"><span class="std std-ref">File system and URLs</span></a> for more details about the:cref:<cite>CCL::Url</cite> class and its string representations.
See also <a class="reference internal" href="details/virtualfilesystem.html#virtual-file-system"><span class="std std-ref">Virtual File System</span></a> for details about the supported protocols for files from other sources.</p>
</section>
<section id="threads">
<h2>Threads<a class="headerlink" href="#threads" title="Link to this heading"></a></h2>
<p>The easiest way to create a background thread is by deriving from the <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/class_CCL_Threading_UserThread.html#doxid-class-c-c-l-1-1-threading-1-1-user-thread"><span class="std std-ref"><span class="pre">CCL::Threading::UserThread</span></span></a></code> helper class. The most commonly used synchronization object probably is <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/class_CCL_Threading_CriticalSection.html#doxid-class-c-c-l-1-1-threading-1-1-critical-section"><span class="std std-ref"><span class="pre">CCL::Threading::CriticalSection</span></span></a></code> in conjunction with <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/struct_CCL_Threading_ScopedLock.html#doxid-struct-c-c-l-1-1-threading-1-1-scoped-lock"><span class="std std-ref"><span class="pre">CCL::Threading::ScopedLock</span></span></a></code>.</p>
</section>
<section id="signals">
<h2>Signals<a class="headerlink" href="#signals" title="Link to this heading"></a></h2>
<p>CCL implements the <a class="reference external" href="http://en.wikipedia.org/wiki/Observer_pattern">observer design pattern</a> for notifications between objects. Dependencies and signaling is handled by the global <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/struct_CCL_ISignalHandler.html#doxid-struct-c-c-l-1-1-i-signal-handler"><span class="std std-ref"><span class="pre">CCL::ISignalHandler</span></span></a></code> singleton accessed via  <code class="doxyrest-cref docutils literal notranslate"><span class="pre">CCL::System::GetSignalHandler</span></code>. Usually you don’t have to call the signal handler directly because the <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/class_CCL_Object.html#doxid-class-c-c-l-1-1-object"><span class="std std-ref"><span class="pre">CCL::Object</span></span></a></code> class already implements methods for this purpose.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">object</span><span class="p">.</span><span class="n">signal</span> <span class="p">(</span><span class="n">Message</span> <span class="p">(</span><span class="n">kChanged</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="plug-ins-and-services">
<h2>Plug-ins and services<a class="headerlink" href="#plug-ins-and-services" title="Link to this heading"></a></h2>
<p>CCL provides a unified plug-in architecture. Plug-in DLLs (or bundles on macOS) export a single C-style function named ‘CCLGetClassFactory’ which returns a pointer to the DLL’s factory object based on the <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/struct_CCL_IClassFactory.html#doxid-struct-c-c-l-1-1-i-class-factory"><span class="std std-ref"><span class="pre">CCL::IClassFactory</span></span></a></code> interface. All plug-in and public framework classes are managed by a central <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/struct_CCL_IPlugInManager.html#doxid-struct-c-c-l-1-1-i-plug-in-manager"><span class="std std-ref"><span class="pre">CCL::IPlugInManager</span></span></a></code> instance which you can access via  <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/namespace_CCL_System.html#doxid-namespace-c-c-l-1-1-system-1a7d1581bb597f9f6fc54a5d6d3dc8ca59"><span class="std std-ref"><span class="pre">CCL::System::GetPlugInManager</span></span></a></code>. Contrary to built-in framework classes, objects created from plug-in DLLs via <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/namespace_CCL.html#doxid-namespace-c-c-l-1aca367eab4c59a96a662ae321f84739be"><span class="std std-ref"><span class="pre">CCL::ccl_new</span></span></a></code> have to be destroyed via <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/namespace_CCL.html#doxid-namespace-c-c-l-1a2d52976d9975f5da4c67050702b953dd"><span class="std std-ref"><span class="pre">CCL::ccl_release</span></span></a></code> to ensure that the binary image is unloaded from memory when the last class instance is released.</p>
<p>The plug-in manager also transparently loads DLLs based on the low-level Core plug-in API, and classes implemented in JavaScript.</p>
<p>Services are extensions to the framework like scripting support, managed by the <code class="doxyrest-cref docutils literal notranslate"><a class="reference internal" href="reference/struct_CCL_IServiceManager.html#doxid-struct-c-c-l-1-1-i-service-manager"><span class="std std-ref"><span class="pre">CCL::IServiceManager</span></span></a></code> singleton. A service is started when the host application starts up and remains active until the host shuts down.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="CCL Cross-platform Framework" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="building.html" class="btn btn-neutral float-right" title="Building CCL" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, CCL Software Licensing GmbH.
      <span class="lastupdated">Last updated on Jan 13, 2026.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>